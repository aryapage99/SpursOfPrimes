# -*- coding: utf-8 -*-
"""representingNums.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W96l06FcnoZDQrhGBHZoOxzX4II-Ugz0
"""

import matplotlib.pyplot as plt
import numpy as np
from sympy import Rational
from scipy.optimize import curve_fit

def sieve_of_eratosthenes(limit):
    sieve = [True] * (limit + 1)
    sieve[0], sieve[1] = False, False

    for num in range(2, int(np.sqrt(limit)) + 1):
        if sieve[num]:
            for multiple in range(num * num, limit + 1, num):
                sieve[multiple] = False

    primes = [i for i in range(limit + 1) if sieve[i]]
    return primes

def alternating_sum_of_primes(limit):
    primes = sieve_of_eratosthenes(limit)
    alternating_sum = 0
    alternating_sums = []
    running_max = []
    running_min = []

    for idx, prime in enumerate(primes):
        if idx % 2 == 0:
            alternating_sum += prime
        else:
            alternating_sum -= prime
        alternating_sums.append(alternating_sum)

        # Calculate running cumulative maximum and minimum
        if idx == 0:
            running_max.append(alternating_sum)
            running_min.append(alternating_sum)
        else:
            running_max.append(max(running_max[-1], alternating_sum))
            running_min.append(min(running_min[-1], alternating_sum))

    return alternating_sums, running_max, running_min

def exp_decay_func(x, a, b, c):
    return a * np.exp(-b * x) + c

def running_extremes_fit(indices, running_extremes):
    x = np.array(indices)
    y = np.array(running_extremes)

    popt, _ = curve_fit(exp_decay_func, x, y, p0=(y[0], 0.01, y[-1]))

    return popt

def print_simplified_function(coefficients):
    simplified_coeffs = [Rational(coeff).limit_denominator() for coeff in coefficients]
    print(f"{simplified_coeffs[0]} * exp(-{simplified_coeffs[1]} * x) + {simplified_coeffs[2]}")

def plot_alternating_sum_with_running_extremes(indices, alternating_sums, running_max, running_min):
    plt.figure(figsize=(10, 6))

    # Plot the alternating sum of primes
    plt.plot(indices, alternating_sums, label='Alternating Sum of Primes', marker='o')

    # Plot the running cumulative maximum and minimum
    plt.plot(indices, running_max, label='Running Max', linestyle='--')
    plt.plot(indices, running_min, label='Running Min', linestyle='--')

    plt.xlabel('Indices')
    plt.ylabel('Cumulative Alternating Sum of Primes')
    plt.title('Alternating Sum of Primes with Running Extremes')
    plt.legend()
    plt.grid(True)
    plt.show()

# Set the limit for calculating the alternating sum of primes
limit = 1000  # Adjust the limit as needed

alternating_sums, running_max, running_min = alternating_sum_of_primes(limit)
indices = np.arange(1, len(alternating_sums) + 1)

plot_alternating_sum_with_running_extremes(indices, alternating_sums, running_max, running_min)

# Calculate and print the best-fit functions for running max and min
max_coeffs = running_extremes_fit(indices, running_max)
min_coeffs = running_extremes_fit(indices, running_min)

print("Best-Fit Function for Running Maximum:")
print_simplified_function(max_coeffs)

print("\nBest-Fit Function for Running Minimum:")
print_simplified_function(min_coeffs)